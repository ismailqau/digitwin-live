// Prisma schema for Real-Time Conversational Clone System
// Database: PostgreSQL 15+

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// User Management
// ============================================================================

model User {
  id        String    @id @default(uuid())
  email     String    @unique
  name      String
  createdAt DateTime  @default(now()) @map("created_at")
  updatedAt DateTime  @updatedAt @map("updated_at")
  deletedAt DateTime? @map("deleted_at") // Soft delete

  // Personality configuration
  personalityTraits String[] @map("personality_traits")
  speakingStyle     String?  @map("speaking_style")

  // AI provider preferences
  preferredLLMProvider String? @map("preferred_llm_provider")
  preferredTTSProvider String? @map("preferred_tts_provider")

  // Usage and limits
  conversationMinutesUsed Int    @default(0) @map("conversation_minutes_used")
  subscriptionTier        String @default("free") @map("subscription_tier")

  // Settings (stored as JSON)
  settings Json @default("{}")

  // Relations
  voiceModels          VoiceModel[]
  voiceSamples         VoiceSample[]
  trainingJobs         TrainingJob[]
  faceModels           FaceModel[]
  conversationSessions ConversationSession[]
  knowledgeDocuments   KnowledgeDocument[]
  faqs                 FAQ[]
  auditLogs            AuditLog[]

  @@index([email])
  @@index([deletedAt])
  @@map("users")
}

// ============================================================================
// WebSocket Sessions
// ============================================================================

model WebSocketSession {
  id                  String   @id @default(uuid())
  userId              String   @map("user_id")
  connectionId        String   @unique @map("connection_id")
  state               String   @default("idle")
  conversationHistory Json     @default("[]") @map("conversation_history")
  createdAt           DateTime @default(now()) @map("created_at")
  lastActivityAt      DateTime @default(now()) @map("last_activity_at")
  expiresAt           DateTime @map("expires_at")

  @@index([userId])
  @@index([connectionId])
  @@index([expiresAt])
  @@map("sessions")
}

// ============================================================================
// Voice Models
// ============================================================================

model VoiceModel {
  id           String    @id @default(uuid())
  userId       String    @map("user_id")
  provider     String // 'xtts-v2', 'google-cloud-tts', 'openai-tts'
  modelPath    String    @map("model_path")
  sampleRate   Int       @default(22050) @map("sample_rate")
  qualityScore Float     @map("quality_score")
  isActive     Boolean   @default(false) @map("is_active")
  status       String    @default("pending") @map("status") // 'pending', 'training', 'completed', 'failed'
  createdAt    DateTime  @default(now()) @map("created_at")
  updatedAt    DateTime  @updatedAt @map("updated_at")
  deletedAt    DateTime? @map("deleted_at") // Soft delete

  // Metadata (stored as JSON)
  metadata Json @default("{}")

  // Relations
  user         User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  trainingJobs TrainingJob[]

  @@index([userId, isActive])
  @@index([status])
  @@index([deletedAt])
  @@map("voice_models")
}

// ============================================================================
// Voice Samples
// ============================================================================

model VoiceSample {
  id               String    @id @default(uuid())
  userId           String    @map("user_id")
  filename         String
  originalFilename String    @map("original_filename")
  contentType      String    @map("content_type")
  sizeBytes        Int       @map("size_bytes")
  duration         Float // Duration in seconds
  sampleRate       Int       @map("sample_rate")
  channels         Int       @default(1)
  qualityScore     Float     @map("quality_score")
  storagePath      String    @map("storage_path") // GCS path
  processedPath    String?   @map("processed_path") // Processed audio path
  status           String    @default("pending") @map("status") // 'pending', 'processing', 'completed', 'failed'
  createdAt        DateTime  @default(now()) @map("created_at")
  updatedAt        DateTime  @updatedAt @map("updated_at")
  deletedAt        DateTime? @map("deleted_at") // Soft delete

  // Metadata (stored as JSON)
  metadata Json @default("{}")

  // Relations
  user                      User                       @relation(fields: [userId], references: [id], onDelete: Cascade)
  trainingJobVoiceSamples   TrainingJobVoiceSample[]

  @@index([userId, status])
  @@index([deletedAt])
  @@map("voice_samples")
}

// ============================================================================
// Training Jobs
// ============================================================================

model TrainingJob {
  id               String    @id @default(uuid())
  userId           String    @map("user_id")
  voiceModelId     String?   @map("voice_model_id") // Null until model is created
  provider         String // 'xtts-v2', 'google-cloud-tts', 'openai-tts'
  status           String    @default("queued") @map("status") // 'queued', 'running', 'completed', 'failed', 'cancelled'
  progress         Float     @default(0) @map("progress") // 0-100
  estimatedCost    Float     @map("estimated_cost")
  actualCost       Float?    @map("actual_cost")
  estimatedTimeMs  Int       @map("estimated_time_ms")
  actualTimeMs     Int?      @map("actual_time_ms")
  startedAt        DateTime? @map("started_at")
  completedAt      DateTime? @map("completed_at")
  failedAt         DateTime? @map("failed_at")
  cancelledAt      DateTime? @map("cancelled_at")
  errorMessage     String?   @map("error_message")
  retryCount       Int       @default(0) @map("retry_count")
  maxRetries       Int       @default(3) @map("max_retries")
  priority         Int       @default(50) @map("priority") // 0-100, higher = more priority
  gpuNodeId        String?   @map("gpu_node_id") // Which GPU node is processing
  jobData          Json      @default("{}") @map("job_data") // Training configuration
  logs             Json      @default("[]") @map("logs") // Training logs
  qualityMetrics   Json?     @map("quality_metrics") // Post-training quality assessment
  createdAt        DateTime  @default(now()) @map("created_at")
  updatedAt        DateTime  @updatedAt @map("updated_at")

  // Relations
  user                      User                       @relation(fields: [userId], references: [id], onDelete: Cascade)
  voiceModel                VoiceModel?                @relation(fields: [voiceModelId], references: [id], onDelete: SetNull)
  trainingJobVoiceSamples   TrainingJobVoiceSample[]

  @@index([userId, status])
  @@index([status, priority])
  @@index([createdAt])
  @@index([gpuNodeId])
  @@map("training_jobs")
}

// ============================================================================
// Training Job Voice Samples (Many-to-Many)
// ============================================================================

model TrainingJobVoiceSample {
  trainingJobId  String @map("training_job_id")
  voiceSampleId  String @map("voice_sample_id")
  assignedAt     DateTime @default(now()) @map("assigned_at")

  // Relations
  trainingJob  TrainingJob  @relation(fields: [trainingJobId], references: [id], onDelete: Cascade)
  voiceSample  VoiceSample  @relation(fields: [voiceSampleId], references: [id], onDelete: Cascade)

  @@id([trainingJobId, voiceSampleId])
  @@map("training_job_voice_samples")
}

// ============================================================================
// Face Models
// ============================================================================

model FaceModel {
  id           String    @id @default(uuid())
  userId       String    @map("user_id")
  modelPath    String    @map("model_path")
  resolution   Json // { width: number, height: number }
  qualityScore Float     @map("quality_score")
  isActive     Boolean   @default(false) @map("is_active")
  createdAt    DateTime  @default(now()) @map("created_at")
  updatedAt    DateTime  @updatedAt @map("updated_at")
  deletedAt    DateTime? @map("deleted_at") // Soft delete

  // Metadata (stored as JSON)
  metadata Json @default("{}")

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, isActive])
  @@index([deletedAt])
  @@map("face_models")
}

// ============================================================================
// Conversation Sessions
// ============================================================================

model ConversationSession {
  id              String    @id @default(uuid())
  userId          String    @map("user_id")
  startedAt       DateTime  @default(now()) @map("started_at")
  endedAt         DateTime? @map("ended_at")
  durationSeconds Int       @default(0) @map("duration_seconds")
  state           String    @default("idle") // 'idle', 'listening', 'processing', 'speaking', 'interrupted', 'error'
  currentTurnId   String?   @map("current_turn_id")

  // Configuration
  llmProvider  String  @map("llm_provider")
  ttsProvider  String  @map("tts_provider")
  voiceModelId String? @map("voice_model_id")
  faceModelId  String? @map("face_model_id")

  // Metrics
  totalTurns       Int   @default(0) @map("total_turns")
  averageLatencyMs Float @default(0) @map("average_latency_ms")
  totalCost        Float @default(0) @map("total_cost")

  // Relations
  user  User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  turns ConversationTurn[]

  @@index([userId, startedAt])
  @@index([state])
  @@map("conversation_sessions")
}

// ============================================================================
// Conversation Turns
// ============================================================================

model ConversationTurn {
  id        String   @id @default(uuid())
  sessionId String   @map("session_id")
  timestamp DateTime @default(now())

  // User input
  userAudioDurationMs  Int    @map("user_audio_duration_ms")
  userTranscript       String @map("user_transcript")
  transcriptConfidence Float  @map("transcript_confidence")

  // System response
  retrievedChunks         String[] @map("retrieved_chunks")
  llmResponse             String   @map("llm_response")
  responseAudioDurationMs Int      @map("response_audio_duration_ms")

  // Performance metrics
  asrLatencyMs   Int @map("asr_latency_ms")
  ragLatencyMs   Int @map("rag_latency_ms")
  llmLatencyMs   Int @map("llm_latency_ms")
  ttsLatencyMs   Int @map("tts_latency_ms")
  totalLatencyMs Int @map("total_latency_ms")

  // Costs
  asrCost   Float @map("asr_cost")
  llmCost   Float @map("llm_cost")
  ttsCost   Float @map("tts_cost")
  totalCost Float @map("total_cost")

  // Relations
  session ConversationSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@index([sessionId, timestamp])
  @@map("conversation_turns")
}

// ============================================================================
// Knowledge Base Documents
// ============================================================================

model KnowledgeDocument {
  id          String    @id @default(uuid())
  userId      String    @map("user_id")
  filename    String
  contentType String    @map("content_type")
  sizeBytes   Int       @map("size_bytes")
  uploadedAt  DateTime  @default(now()) @map("uploaded_at")
  processedAt DateTime? @map("processed_at")

  // Content
  textContent String @map("text_content") @db.Text
  chunkCount  Int    @default(0) @map("chunk_count")

  // Metadata
  title     String?
  author    String?
  sourceUrl String?  @map("source_url")
  tags      String[]

  // Processing status
  status       String  @default("pending") // 'pending', 'processing', 'completed', 'failed'
  errorMessage String? @map("error_message")

  // Storage
  storagePath String   @map("storage_path")
  vectorIds   String[] @map("vector_ids")

  // Analytics metadata (stored as JSON)
  metadata Json @default("{}")

  deletedAt DateTime? @map("deleted_at") // Soft delete

  // Relations
  user   User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  chunks DocumentChunk[]

  @@index([userId, uploadedAt])
  @@index([status])
  @@index([deletedAt])
  @@map("knowledge_documents")
}

// ============================================================================
// FAQs
// ============================================================================

model FAQ {
  id        String    @id @default(uuid())
  userId    String    @map("user_id")
  question  String
  answer    String    @db.Text
  priority  Int       @default(50) // 0-100, higher = more important
  tags      String[]
  createdAt DateTime  @default(now()) @map("created_at")
  updatedAt DateTime  @updatedAt @map("updated_at")
  deletedAt DateTime? @map("deleted_at") // Soft delete

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, priority])
  @@index([deletedAt])
  @@map("faqs")
}

// ============================================================================
// Vector Storage (PostgreSQL with pgvector extension)
// ============================================================================

model DocumentChunk {
  id         String   @id @default(uuid())
  documentId String   @map("document_id")
  userId     String   @map("user_id")
  chunkIndex Int      @map("chunk_index")
  content    String   @db.Text
  embedding  String   @db.Text // Stored as text representation of vector for pgvector
  embeddingVector Unsupported("vector(768)")? @map("embedding_vector") // pgvector column for similarity search
  metadata   Json     @default("{}")
  createdAt  DateTime @default(now()) @map("created_at")

  // Relations
  document KnowledgeDocument @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@unique([documentId, chunkIndex])
  @@index([userId])
  @@index([documentId])
  @@map("document_chunks")
}

// ============================================================================
// Cache Tables (L2 Cache - PostgreSQL)
// ============================================================================

model EmbeddingCache {
  id        String   @id @default(uuid())
  queryHash String   @unique @map("query_hash") // Hash of the query text
  embedding Float[] // Vector embedding (for application use)
  embeddingVector Unsupported("vector(768)")? @map("embedding_vector") // pgvector column for similarity search
  createdAt DateTime @default(now()) @map("created_at")
  expiresAt DateTime @map("expires_at")

  @@index([queryHash])
  @@index([expiresAt])
  @@map("embedding_cache")
}

model VectorSearchCache {
  id        String   @id @default(uuid())
  queryHash String   @map("query_hash") // Hash of query + filters
  userId    String   @map("user_id")
  results   Json // Cached search results
  createdAt DateTime @default(now()) @map("created_at")
  expiresAt DateTime @map("expires_at")

  @@index([queryHash, userId])
  @@index([expiresAt])
  @@map("vector_search_cache")
}

model LLMResponseCache {
  id         String   @id @default(uuid())
  promptHash String   @map("prompt_hash") // Hash of the prompt
  response   String   @db.Text
  provider   String
  createdAt  DateTime @default(now()) @map("created_at")
  expiresAt  DateTime @map("expires_at")
  hitCount   Int      @default(0) @map("hit_count")

  @@index([promptHash])
  @@index([expiresAt])
  @@map("llm_response_cache")
}

model AudioChunkCache {
  id             String   @id @default(uuid())
  cacheKey       String   @unique @map("cache_key") // Hash of text + voice settings + session
  audioData      Bytes    @map("audio_data") // Compressed audio data (Opus codec)
  format         String   @default("opus") // 'opus', 'mp3', 'pcm'
  durationMs     Int      @map("duration_ms")
  sampleRate     Int      @default(16000) @map("sample_rate")
  channels       Int      @default(1) // Mono
  compression    String   @default("opus") // Compression codec used
  storagePath    String?  @map("storage_path") // GCS path for archived audio
  metadata       Json     @default("{}") // Additional metadata (voice model, session info)
  createdAt      DateTime @default(now()) @map("created_at")
  expiresAt      DateTime @map("expires_at")
  hitCount       Int      @default(0) @map("hit_count")
  lastAccessedAt DateTime @default(now()) @map("last_accessed_at")

  @@index([cacheKey])
  @@index([expiresAt])
  @@index([lastAccessedAt])
  @@index([storagePath])
  @@map("audio_chunk_cache")
}

// ============================================================================
// Rate Limiting
// ============================================================================

model RateLimit {
  id           String   @id @default(uuid())
  userId       String   @map("user_id")
  endpoint     String
  windowStart  DateTime @map("window_start")
  requestCount Int      @default(0) @map("request_count")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  @@unique([userId, endpoint, windowStart])
  @@index([userId, endpoint, windowStart])
  @@index([windowStart])
  @@map("rate_limits")
}

// ============================================================================
// Query Analytics
// ============================================================================

model QueryAnalytics {
  id                 String   @id @default(uuid())
  query              String
  userId             String   @map("user_id")
  timestamp          DateTime @default(now())
  resultsCount       Int      @map("results_count")
  avgRelevanceScore  Float    @map("avg_relevance_score")
  hasLowConfidence   Boolean  @map("has_low_confidence")

  @@index([userId, timestamp])
  @@index([query])
  @@index([hasLowConfidence])
  @@index([timestamp])
  @@map("query_analytics")
}

// ============================================================================
// Audit Logging
// ============================================================================

model AuditLog {
  id        String   @id @default(uuid())
  timestamp DateTime @default(now())
  userId    String   @map("user_id")
  action    String
  resource  String
  result    String // 'success', 'failure'
  ipAddress String?  @map("ip_address")
  userAgent String?  @map("user_agent")
  metadata  Json     @default("{}")

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, timestamp])
  @@index([action])
  @@index([timestamp])
  @@map("audit_logs")
}
